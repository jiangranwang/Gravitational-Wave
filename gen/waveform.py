import numpy as np
from pycbc.waveform import *
from pycbc.pnutils import *
from scipy.interpolate import interp1d
import matplotlib.mlab as mlab
import pickle

SOLAR_MASS_TO_SEC = 4.92549095e-6


class Waveform:
    """
    Wrapper class for a single waveform. The initialization of a Waveform 
    object sets the specification (mass, spin) of the two black holes; and
    calling the ``gen_waveform`` method on a Waveform object generates and
    clips the desired waveform using PyCBC.

    """

    def __init__(self, m1, m2, s1, s2):
        """
        Initialize a waveform object modeling the waveform generated by the
        collision of two black holes.

        Parameters
        ----------
        m1, m2 : float
            Masses of the black holes in unit of solar mass. The heavier black
            hole will be labeled as m1/s1, if it is not already.
        s1, s2 : tuple
            Spins of the black holes in tuples of three floats, representing
            the x, y, and z direction respectively.

        """
        if m1 < m2:
            m1, m2 = m2, m1
            s1, s2 = s2, s1
        self.m1 = m1
        self.m2 = m2
        self.m_tot = m1 + m2
        self.s1 = s1
        self.s2 = s2
        self.q = m1 / m2  # mass ratio
        self.failed = False
        assert len(s1) == len(s2) == 3
        self.waveform = None

    def _run_simulation_core(self, f_lower, delta_t, approximant):
        """
        Run simulation using PyCBC's ``get_td_waveform`` function.

        Parameters
        ----------
        f_lower : float
            Starting frequency of the waveform in Hz.
        delta_t : float
            Time step in seconds.
        approximant : string
            Proximant of the waveform (see PyCBC docs for details).

        """
        hp, hc = get_td_waveform(approximant=approximant,
                                 mass1=self.m1,
                                 mass2=self.m2,
                                 spin1x=self.s1[0],
                                 spin1y=self.s1[1],
                                 spin1z=self.s1[2],
                                 spin2x=self.s2[0],
                                 spin2y=self.s2[1],
                                 spin2z=self.s2[2],
                                 f_lower=f_lower,
                                 delta_t=delta_t)
        
        scale_factor = 1.  # the factor here is for scaling the total mass by two times, default 1. meaning using the original mass, otherwise use the new_total_mass = scale_factor * original_total_mass
        time = hp.sample_times.data * scale_factor
        first_pos_idx = (time <= 0).sum()
        norm_denom = np.sqrt(hp.data[first_pos_idx] ** 2 +
                             hc.data[first_pos_idx] ** 2)
        
        amp = hp.data / norm_denom
        
        return time, amp

    def gen_waveform(self, initial_f_lower=30., delta_t=1./8192.,
                     approximant='SEOBNRv3', num_secs=1., max_tries=5,
                     pxxStr='pxxH1-150914-8', freqsStr='freqsH1-150914-8'):
        """
        Generate the waveform for the specified parameters using PyCBC.
        
        Note
        ----
        We will start simulation at a larger ``f_lower`` value. If the 
        generated waveform is not long enough, we will reduce ``f_lower`` by 
        half and retry. If we still cannot get a long-enough waveform, -1 is 
        returned and ``self.failed`` is set to True.
        
        Parameters
        ----------
        initial_f_lower : float, optional
            The initial ``f_lowe``r value to attempt simulation with, in Hz. 
            The default value is 30 Hz.
        max_tries : int, optional
            We will give up simulation if the waveform is still too short 
            after reducing ``f_lower`` this number of times. The default value
            is 5.
        delta_t : float, optional
            The time step to run simulation at. The default is 1/8192.
        approximant : str, optional
            The approximant to use for the simulation. See PyCBC docs for 
            details. The default value is SEOBNRv3.
        num_secs : float, optional
            The number of seconds to trim the waveform to. The default value
            is 1 sec.

        Returns
        -------
        int
            Number of tries it took to generate the waveform. If failed, 
            returns -1.
        """
        with open("/home/jw22/code/" + freqsStr, "rb") as fh:
            self.freqs = pickle.load(fh)
        with open("/home/jw22/code/" + pxxStr, "rb") as fh:
            self.pxx = pickle.load(fh)
            self.psd = interp1d(self.freqs, self.pxx)

        curr_f_lower = self.f_init(self.m_tot, self.q, num_secs)
        for i in range(max_tries):
            time, amp = self._run_simulation_core(f_lower=curr_f_lower,
                                                  delta_t=delta_t,
                                                  approximant=approximant)
            # note that PyCBC counts time from final collision backwards
            if -time[0] < num_secs:
                curr_f_lower /= 2.
                continue  # not long enough
            mask = (time >= (-num_secs - 900. * delta_t)) & (time < 1600. * delta_t)  # changed part
            time, amp = time[mask], amp[mask]
            f = interp1d(time, amp, fill_value="extrapolate")
            time_interp = np.linspace(-num_secs + 750 * num_secs * delta_t, 750 * num_secs * delta_t,
                                      int(num_secs / delta_t))  # new one that's working
            amp_interp = f(time_interp)
            self.waveform = self.whiten_wrapper(amp_interp, 1./8192.)
            return i + 1
        self.failed = True
        return -1

    def f_init(self, M, q, t):
        M = M * 1.989 * 10 ** 30
        return (((8 * 3.1415926) ** (8 / 3.) / 5.) * (
                6.67408 * 10. ** (-11) * (M ** 2 * q / (1 + q) ** 2) ** (3 / 5.) / (M ** (1 / 5.)) / (
                299792458. ** 3)) ** (5 / 3.) * t) ** (-3 / 8.) - 1.7326
    
    def whiten_wrapper(self, wave, dt):
        # function to whiten data
        def whiten(strainW, interp_psd, dt):
            Nt = len(strainW)
            freqsW = np.fft.rfftfreq(Nt, dt)

            # whitening: transform to freq domain, divide by asd, then transform back, 
            # taking care to get normalization right.
            hf = np.fft.rfft(strainW)
            white_hf = hf / (np.sqrt(interp_psd(freqsW) /dt/2.))
            white_ht = np.fft.irfft(white_hf, n=Nt)
            return white_ht

        wave_whiten = whiten(wave, self.psd, dt)
        wave_whiten[:100] = 0
        wave_whiten[-100:] = 0
        wave_whiten = (wave_whiten - np.mean(wave_whiten)) / np.std(wave_whiten)
        return wave_whiten
